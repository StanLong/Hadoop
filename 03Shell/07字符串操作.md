# 字符串操作

```shell
# 字符串准备
[root@node01 ~]# a="hello"
[root@node01 ~]# b="world"

# 字符串拼接
[root@node01 ~]# c=$a$b
[root@node01 ~]# echo $c
helloworld
[root@node01 ~]# c=$a" "$b
[root@node01 ~]# echo $c
hello world

# 取字符串的长度
# echo ${#string}
[root@node01 ~]# echo ${#a}
5

# 左边截取字符串
# ${string: start :length}， 从0开始数
[root@node01 ~]# echo ${a:0} # 从 0 截取到最后
hello
[root@node01 ~]# echo ${a:0:1} # 从0开始截取一个字符
h

# 右边截取字符串
# ${string: 0-start :length} 从1开始数
[root@node01 ~]# echo ${a:0-1} # 从右边截一个
o
[root@node01 ~]# echo ${a:0-2} # 从右边截两个
lo
[root@node01 ~]# echo ${a:0-2:1} # 截取的字符串保留一个
l
[root@node01 ~]# echo ${a:0-2:2} # 截取的字符串保留两个
lo
```

**字符串截取功能扩展**

```
#是去掉左边（键盘上#在 $ 的左边）
%是去掉右边（键盘上% 在$ 的右边）
单一符号#，%是最小匹配；两个符号##，%%是最大匹配
这种语法，我自己给他取个名字，“砍头去尾” 语法，这个用法通常会搭配通配符 '*' 来使用
```

```shell
# 定义变量
[root@node01 hive]# path=/opt/stanlong/hive
[root@node01 hive]# echo $path
/opt/stanlong/hive

# 最小匹配，删掉 path 左边 第一次出现的 / 
[root@node01 hive]# echo ${path#*/}  # {*/ 表示匹配0或0个以上的 /}
opt/stanlong/hive

# 示例：使用最小匹配截取文件扩展名
[hadoop@hadoop101 zlf]$ file="video.mp4"
[hadoop@hadoop101 zlf]$ echo $file
[hadoop@hadoop101 zlf]$ echo ${file#*.}
mp4


# 最大匹配， 删除最后一个 / 及其左边所有的内容
[root@node01 hive]# echo ${path##*/}
hive


# 定义变量
[root@node01 hive]# path=opt/stanlong/hive/
[root@node01 hive]# echo $path
opt/stanlong/hive/

# 最小匹配，删除右边出现的 / 
[root@node01 hive]# echo ${path%/*}
opt/stanlong/hive

# 最大匹配，删除第一次出现 / 及其右边所有的内容
[root@node01 hive]# echo ${path%%/*}
opt
```

