# 常用函数

Hive提供了大量的内置函数，按照其特点可大致分为如下几类：单行函数、聚合函数、炸裂函数、窗口函数。

## 一、查看函数

```mysql
-- 查看系统自带函数
show functions;  -- hive 内置函数一共290个

show functions like "*string*";  -- 根据函数名称模糊查看函数

desc function substring; -- 查看函数的用法

desc function extended substring; -- 查看函数详细信息
```

## 二、单行函数

### 1、算法运算函数

- 单行函数的特点是一进一出，即输入一行，输出一行。
- 单行函数按照功能可分为如下几类: 日期函数、字符串函数、集合函数、数学函数、流程控制函数等

![](https://i-blog.csdnimg.cn/blog_migrate/36daf4617c1c6299674b28d9d86e33eb.png)

### 2、数值函数

数值函数是用于**对数值数据进行操作和计算的函数**，在 SQL 查询中经常用于执行数学运算、取值范围限制等操作。

- ABS(x)：返回 x 的绝对值。

- ROUND(x, d)：将 x 四舍五入到 d 位小数。如果 d 被省略，则默认为 0。

- CEIL(x)：返回不小于 x 的最小整数，向上取整。

- FLOOR(x)：返回不大于 x 的最大整数，向下取整。

- SQRT(x)：返回 x 的平方根。

- POWER(x, y)：返回 x 的 y 次幂。

- EXP(x)：返回 e 的 x 次幂，其中 e 是自然对数的底。

- LOG(x)：返回 x 的自然对数。

- LOG10(x)：返回 x 的以 10 为底的对数。

- MOD(x, y)：返回 x 除以 y 的余数。

- SIGN(x)：返回 x 的符号：1 表示正数，-1 表示负数，0 表示零。

- RAND()：返回一个随机浮点数值，范围在 0 到 1 之间。

- 示例

  ```mysql
  -- 返回 -5 的绝对值
  SELECT ABS(-5); -- 输出: 5
  
  -- 将 4.8 四舍五入到最近的整数
  SELECT ROUND(4.8); -- 输出: 5
  
  -- 返回不小于 4.8 的最小整数
  SELECT CEIL(4.8); -- 输出: 5
  
  -- 返回不大于 4.8 的最大整数
  SELECT FLOOR(4.8); -- 输出: 4
  
  -- 返回 25 的平方根
  SELECT SQRT(25); -- 输出: 5
  
  -- 返回 2 的 3 次幂
  SELECT POWER(2, 3); -- 输出: 8
  
  -- 返回 e 的 2 次幂
  SELECT EXP(2); -- 输出: 约为 7.389
  
  -- 返回 100 的自然对数
  SELECT LOG(100); -- 输出: 约为 4.605
  
  -- 返回 100 的以 10 为底的对数
  SELECT LOG10(100); -- 输出: 2
  
  -- 返回 10 除以 3 的余数
  SELECT MOD(10, 3); -- 输出: 1
  
  -- 返回 -5 的符号：-1 表示负数
  SELECT SIGN(-5); -- 输出: -1
  
  -- 返回一个范围在 0 到 1 之间的随机浮点数
  SELECT RAND(); -- 输出: 0.xxxx (实际结果会变化)
  ```

### 3、字符串函数

- concat(str1, str2, …)：连接字符串。

  语法：concat(string A, string B, string C, ……)

  返回：string

  说明：将A,B,C……等字符拼接为一个字符串

  ```mysql
  hive> select concat('beijing','-','shanghai','-','shenzhen');
  输出：
  hive> beijing-shanghai-shenzhen
  
  -- hive 中还有另外一种语法可以实现拼接
  select "beijing"||"-"||"shanghai"||"-"||"shenzhen";
  ```

- concat_ws：以指定分隔符拼接字符串或者字符串数组

  语法：concat_ws(string A, string…| array(string))
  返回值：string
  说明：使用分隔符A拼接多个字符串，或者一个数组的所有元素。

  ```mysql
  hive> select concat_ws('-','beijing','shanghai','shenzhen');
  输出：
  hive> beijing-shanghai-shenzhen
  
  -- 也可以将数组中的内容拼接到一起
  hive> select concat_ws('-',array('beijing','shenzhen','shanghai'));
  输出：
  hive> beijing-shanghai-shenzhen
  ```

- upper(str)：将字符串转换为大写。

  ```mysql
  -- 将 'hello' 转换为大写
  SELECT upper('hello'); -- 输出: 'HELLO'
  ```

- lower(str)：将字符串转换为小写。

  ```mysql
  -- 将 'WORLD' 转换为小写
  SELECT lower('WORLD'); -- 输出: 'world'
  ```

- length(str)：返回字符串的长度。

  ```mysql
  -- 返回字符串 'hello world' 的长度
  SELECT length('hello world'); -- 输出: 11
  ```

- substr(str, start, length)：提取子串。

  ```mysql
  -- 提取字符串 'hello world' 的前 5 个字符
  SELECT substr('hello world', 1, 5); 
  -- 输出: 'hello'
  
  -- 获取倒数第三个字符以后的所有字符
  select substring("yushifu",-3); 
  -- 输出：ifu
  ```

- replace(str, from_str, to_str)：替换字符串中的子串。

  ```mysql
  -- 将字符串 'hello world' 中的 'hello' 替换为 'hi'
  SELECT replace('hello world', 'hello', 'hi');
  -- 输出: 'hi world'
  ```

- trim：去除字符串两侧或指定位置的空格或指定字符。

  ```mysql
  -- 去除字符串 '   hello world   ' 两侧的空格
  SELECT trim('   hello world   '); -- 输出: 'hello world'
  ```

- ltrim(str)：去除字符串左侧的空格。

  ```mysql
  -- 去除字符串 '   hello' 左侧的空格
  SELECT ltrim('   hello'); -- 输出: 'hello'
  ```

- rtrim(str)：去除字符串右侧的空格。

  ```mysql
  -- 去除字符串 'world   ' 右侧的空格
  SELECT rtrim('world   '); -- 输出: 'world'
  ```

- regexp_replace 函数用于使用正则表达式替换字符串中的匹配项。

  ```mysql
  -- 使用正则表达式替换字符串中的数字为 'X'
  SELECT regexp_replace('Hello 123 World 456', '\\d+', 'X');
  -- 输出: 'Hello X World X'
  -- '\\d+' 是一个正则表达式，用于匹配一个或多个数字。'X' 是替换字符串。所以，regexp_replace 函数将字符串中的所有数字替换为 'X'。
  ```

- regexp 正则匹配

  语法：字符串 regexp 正则表达示

  返回值： boolean

  说明：正则匹配成功，输出 true, 匹配失败，返回 false

  ```mysql
  select 'dfsaaaaa' regexp 'dfsa+';
  -- 输出 ： ture
  
  select 'dfsaaaaa' regexp 'dfsb+';
  -- 输出 : false
  ```

- RLIKE

  RLIKE子句是Hive中这个功能的一个扩展，其可以通过Java的正则表达式这个更强大的语言来指定匹配条件

  ```mysql
  -- 找出以S开头,以H结尾的员工名称
  select * from emp where ename Rlike '^S.*H$';
  ```

- repeat：重复字符串

  语法：repeat(string A, int n)
  返回值：string
  说明：将字符串A重复n遍。

  ```mysql
  hive> select repeat('123', 3);
  输出：
  hive> 123123123
  ```

- split ：字符串切割

  语法：split(string str, string pat)
  返回值：array
  说明：按照正则表达式pat匹配到的内容分割str，分割后的字符串，以数组的形式返回。

  ```mysql
  hive> select split('a-b-c-d','-');
  输出：
  hive> ["a","b","c","d"]
  ```

- nvl ：替换null值
  语法：nvl(A,B)
  说明：若A的值不为null，则返回A，否则返回B。

  ```mysql
  hive> select nvl(null,1); 
  输出：
  hive> 1
  ```

- get_json_object : 解析json字符串

  语法：get_json_object(string json_string, string path)

  返回值：string

  说明：解析json的字符串json_string，返回path指定的内容。如果输入的json字符串无效，那么返回NULL。

  ```mysql
  hive> select get_json_object('[{"name":"yushifu","sex":"男","age":"24"},{"name":"彭于晏","sex":"男","age":"47"}]','$.[0]');
  输出：
  hive> {"name":"yushifu","sex":"男","age":"24"}
  
  hive> select get_json_object('[{"name":"yushifu","sex":"男","age":"24"},{"name":"彭于晏","sex":"男","age":"47"}]','$.[0].name');
  输出：
  hive> yushifu
  ```

### 4、日期函数

- `unix_timestamp`：**返回当前或指定时间的时间戳**

  语法：unix_timestamp()

  返回值：bigint

  ```mysql
  -- 获取当前时间的时间戳
  hive> select unix_timestamp(); 
  输出： 1723376227
  
  -- 获取指定时间的时间戳
  hive> select unix_timestamp('2024/04/25 09-19-08','yyyy/MM/dd HH-mm-ss');  
  输出：
  1714036748
  ```

- `from_unixtime`：**转化UNIX时间戳（从 1970-01-01 00:00:00 UTC 到指定时间的秒数）到当前时区的时间格式**

  语法：from_unixtime(bigint unixtime[, string format])

  返回值：string

  ```mysql
  -- 时间戳转日期
  hive> select from_unixtime(1714036748);   
  输出：
  2024-04-25 09:19:08

  -- 时间戳按指定格式转日期
  hive> select from_unixtime(1723376227, 'yyyy-MM-dd HH:mm:ss'); 
  输出： 2024-08-11 11:37:07  -- 注意这个时间和当前时间差了8个小时， 这是因为from_unixtime默认将时间戳从UTC时间开始计时，我们是在东8区，所以时间比我们晚了8个小时
  
  -- 解决时区问题,将0时区转成东8区。 注意要将时间戳格式转成bigint， 不然就超范围了， 再乘以1000是将秒转成毫秒。  'GMT+8' 这个是东八区的固定写法
   select from_utc_timestamp(cast(1723376227 as bigint)*1000, 'GMT+8'); 
  ```
  
- `current_date`：**当前日期**

  ```mysql
  hive> select current_date;     
  输出：
  2024-04-25 
  ```

- `current_timestamp`：**当前的日期加时间，并且精确的毫秒**

  ```mysql
  hive> select current_timestamp;   
  输出：
  2024-04-25 09:22:22.726
  ```

- `month`：**获取日期中的月**

  语法：month (string date)

  返回值：int

  ```mysql
  hive> select month('2024-04-25 09:19:08');
  输出：
  4
  ```

- `day`：**获取日期中的日**

  语法：day (string date)

  返回值：int

  ```mysql
  hive> select day('2024-04-25 09:19:08');    
  输出：
  25
  ```

- `hour`：**获取日期中的小时**

  语法：hour (string date)

  返回值：int

  ```mysql
  hive> select hour('2024-04-25 09:19:08');   
  输出：
  9
  ```

- `datediff`：**两个日期相差的天数（结束日期减去开始日期的天数）**

  语法：**datediff(string enddate, string startdate)**

  返回值：int

  ```mysql
  hive> select datediff('2021-08-08','2022-10-09');     -- 需要注意的是datediff两个日期必须是'yyyy-MM-dd'的格式，否则执行结果会是NULL
  输出：
  -427
  ```

- `date_add`：**日期加天数**

  语法：date_add(string startdate, int days)

  返回值：string

  说明：**返回开始日期 startdate 增加 days 天后的日期**

  ```mysql
  hive> select date_add('2022-08-08',2);   
  输出：
  2022-08-10
  ```

- `date_sub`：**日期减天数**

  语法：date_sub (string startdate, int days)

  返回值：string

  说明：**返回开始日期startdate减少days天后的日期。**

  ```mysql
  hive> select date_sub('2022-08-08',2);    
  输出：
  2022-08-06
  ```

- `date_format`:**将标准日期解析成指定格式字符串**

  ```mysql
  hive> select date_format('2022-08-08','yyyy年-MM月-dd日')   
  输出：
  2022年-08月-08日
  ```
  
- next_day函数

  取指定日期所在周的下一周的周一

  ```sql
  hive> select next_day('2021-02-23','MO') as c1;
  +-------------+--+
  |     c1     |
  +-------------+--+
  | 2021-03-01  |
  +-------------+--+
  1 row selected (0.962 seconds)
  ------------------------------------------------------------------------------------
  星期一到星期日的英文（Monday，Tuesday、Wednesday、Thursday、Friday、Saturday、Sunday）
  ```

  取当前周的周一

  ```sql
  hive>  select date_add(next_day('2021-02-23','MO'),-7) as c1;
  +-------------+--+
  |     c1      |
  +-------------+--+
  | 2021-02-22  |
  +-------------+--+
  1 row selected (0.343 seconds)
  ```

2. last_day函数（求当月最后一天日期）

   ```sql
   0: jdbc:hive2://node01:10000> select last_day('2021-02-23') as c1;
   +-------------+--+
   |     c1      |
   +-------------+--+
   | 2021-02-28  |
   +-------------+--+
   1 row selected (0.81 seconds)
   ```

### 5、流程控制函数

- **case when：条件判断函数**

  - 语法一：case when a then b [when c then d]* [else e] end

    返回值：T

    说明：**如果a为true，则返回b；如果c为true，则返回d；否则返回 e**

    ```mysql
    hive> select case when 1=2 then 'tom' when 2=2 then 'mary' else 'tim' end ; 
    mary
    ```

  - 语法二： case a when b then c [when d then e]* [else f] end

    返回值: T

    说明：**如果a等于b，那么返回c；如果a等于d，那么返回e；否则返回f**

    ```mysql
    hive> select case 100 when 50 then 'tom' when 100 then 'mary' else 'tim' end; 
    mary
    ```

-  if: 条件判断，类似于Java中三元运算符

  语法：if（boolean testCondition, T valueTrue, T valueFalseOrNull）

  返回值：T

  说明：当条件testCondition为true时，返回valueTrue；否则返回valueFalseOrNull

  ```mysql
  hive> select if(10 > 5,'正确','错误'); 
  输出：正确
  
  hive> select if(10 < 5,'正确','错误');
  输出：错误
  ```

### 6、集合函数

- **size：集合中元素的个数**

  ```mysql
  hive> select size(friends) from test;  
  --2/2  每一行数据中的friends集合里的个数
  ```

- **map：创建map集合**

  语法：map (key1, value1, key2, value2, …)

  说明：根据输入的key和value对构建map类型

  ```mysql
  hive> select map('uzi',1,'xiaohu',2);  
  输出：
  hive> {"uzi":1,"xiaohu":2}
  ```

- **map_keys： 返回map中的key**

  ```mysql
  hive> select map_keys(map('uzi',1,'xiaohu',2));
  输出：
  hive>["uzi","xiaohu"]
  ```

- **map_values: 返回map中的value**

  ```mysql
  hive> select map_values(map('uzi',1,'xiaohu',2));
  输出：
  hive>[1,2]
  ```

- **array:声明array集合**

  语法：array(val1, val2, …)

  说明：**根据输入的参数构建数组array类**

  ```mysql
  hive> select array('1','2','3','4');
  输出：
  hive>["1","2","3","4"]
  ```

- **array_contains: 判断array中是否包含某个元素**

  ```mysql
  hive> select array_contains(array('a','b','c','d'),'a');
  输出：
  hive> true
  ```

- **sort_array：将array中的元素排序**

  ```mysql
  hive> select sort_array(array('a','d','c'));
  输出：
  hive> ["a","c","d"]
  ```

- **struct:声明struct中的各属性**

  语法：struct(val1, val2, val3, …)

  说明：根据输入的参数构建结构体struct类

  ```mysql
  hive> select struct('name','age','weight');
  输出：
  hive> {"col1":"name","col2":"age","col3":"weight"}
  ```

- **named_struct:声明struct的属性和值**

  ```mysql
  hive> select named_struct('name','uzi','age',18,'weight',80);
  输出：
  hive> {"name":"uzi","age":18,"weight":80}
  ```

### 7、案例

表结构

![](https://i-blog.csdnimg.cn/blog_migrate/989b4c41ba8f36fc7631835e664ed69a.png)

```mysql
-- 建表
create table employee(
    name string,    --姓名
    sex string,    --性别
    birthday string ,
    hiredate string,    --入职日期
    job string,    --岗位
    salary double,    --薪水
    bonus double,    --奖金
    friends array<string>,
    children map<string,int>
)
row format delimited fields terminated by '\t';

-- 插入数据：
insert into employee  
 values('张无忌','男','1980/02/12','2022/08/09','销售',3000,12000,array('阿朱','小昭'),map('张小无',8,'张小忌',9)),
        ('赵敏','女','1982/05/18','2022/09/10','行政',9000,2000,array('阿三','阿四'),map('赵小敏',8)),
       ('宋青书','男','1981/03/15','2022/04/09','研发',18000,1000,array('王五','赵六'),map('宋小青',7,'宋小书',5)),
       ('周芷若','女','1981/03/17','2022/04/10','研发',18000,1000,array('王五','赵六'),map('宋小青',7,'宋小书',5)),
       ('郭靖','男','1985/03/11','2022/07/19','销售',2000,13000,array('南帝','北丐'),map('郭芙',5,'郭襄',4)),
       ('黄蓉','女','1982/12/13','2022/06/11','行政',12000,null,array('东邪','西毒'),map('郭芙',5,'郭襄',4)),
       ('杨过','男','1988/01/30','2022/08/13','前台',5000,null,array('郭靖','黄蓉'),map('杨小过',2)),
       ('小龙女','女','1985/02/12','2022/09/24','前台',6000,null,array('张三','李四'),map('杨小过',2));
```

```mysql
-- 统计每个月的入职人数:month cnt ， 数据里都是2022年入职的，所以这里不需要考虑年份的问题。
select 
    month(replace(hiredate,'/','-')) month, -- 日期格式化，把月份取出来
    count(*) cnt
from employee
group by month(replace(hiredate,'/','-'));
--  或者
select 
	split(hiredate, '/')[1] 
   ,count(1) as c1 
from employee group by split(hiredate, '/')[1];

+------+-----+
| _c0  | c1  |
+------+-----+
| 04   | 2   |
| 06   | 1   |
| 07   | 1   |
| 08   | 2   |
| 09   | 2   |
+------+-----+
-----------------------------------------------------------------------------------------------------------
-- 查询每个人的年龄（年 + 月）:name age
select
    name
   ,concat(floor(month_num/12), '年', round(month_num % 12), '月') as age
from
(
    select
        name
       ,months_between(current_date(), replace(birthday, '/', '-')) as month_num
    from employee
)t
+-------+----------+
| name  |   age    |
+-------+----------+
| 张无忌   | 44年6.0月  |
| 赵敏    | 42年3.0月  |
| 宋青书   | 43年5.0月  |
| 周芷若   | 43年5.0月  |
| 郭靖    | 39年5.0月  |
| 黄蓉    | 41年8.0月  |
| 杨过    | 36年6.0月  |
| 小龙女   | 39年6.0月  |
+-------+----------+

-----------------------------------------------------------------------------------------------------------
-- 按照薪资，奖金的和进行倒序排序，如果奖金为null，置位0:name sal
select 
    name,
    salary+nvl(bonus,0) sal -- 一个int和一个null进行运算的时候其结果是null， 这个时候null需要判断一下
from employee
order by sal desc; 

-----------------------------------------------------------------------------------------------------------
-- 查询每个人有多少个朋友:name cnt
select
    name,
    size(friends) cnt
from employee;

-----------------------------------------------------------------------------------------------------------
-- 查询每个人的孩子的姓名:name ch_name
select
    name,
    map_keys(children) ch_name
from employee;

-----------------------------------------------------------------------------------------------------------
-- 查询每个岗位男女各多少人:job male female
select
    job,
    sum(if(sex='男',1,0)) male,
    sum(if(sex='女',1,0)) female
from employee
group by job;
```

## 三、高级聚合函数

多进一出（多行传入，一行输出）

### 1、普通聚合函数

count、sum、max、min 等

### 2、collect_list 

收集并形成list集合，结果不去重

```mysql
select
    sex,
    collect_list(job)
from employee
group by sex;

+------+------------------------+
| sex  |          _c1           |
+------+------------------------+
| 女    | ["行政","研发","行政","前台"]  |
| 男    | ["销售","研发","销售","前台"]  |
+------+------------------------+
```

### 3、collect_set 

收集并形成set集合，结果去重

```mysql
select
    sex,
    collect_set(job)
from employee
group by sex;

+------+-------------------+
| sex  |        _c1        |
+------+-------------------+
| 女    | ["行政","研发","前台"]  |
| 男    | ["销售","研发","前台"]  |
+------+-------------------+
```

### 4、案例

- 统计每个月的入职人数及姓名

  ```mysql
  select
      month(replace(hiredate, '/', '-')) as month
     ,count(*)
     ,collect_list(name)
  from employee
  group by month(replace(hiredate, '/', '-'));
  
  +--------+------+----------------+
  | month  | _c1  |      _c2       |
  +--------+------+----------------+
  | 4      | 2    | ["宋青书","周芷若"]  |
  | 6      | 1    | ["黄蓉"]         |
  | 7      | 1    | ["郭靖"]         |
  | 8      | 2    | ["张无忌","杨过"]   |
  | 9      | 2    | ["赵敏","小龙女"]   |
  +--------+------+----------------+
  ```

## 四、炸裂函数

![](https://img-blog.csdnimg.cn/direct/e2c97010737541cab515a35ee4c52871.png)

### 1、explode

EXPLODE(col)：将hive一列中复杂的array或者map结构拆分(炸裂开)成多行。

```sql
select explode(array(1,2,3));
+------+
| col  |
+------+
| 1    |
| 2    |
| 3    |
+------+

select explode(map("a",1, "b",2, "c",3)) as (key, value);
+------+--------+
| key  | value  |
+------+--------+
| a    | 1      |
| b    | 2      |
| c    | 3      |
+------+--------+
```

### 2、posexplode

接收一个Array作为参数，除了返回Array中的元素，还会返回元素在Array中的下标

```mysql
select posexplode(array("a", "b", "c")) as (pos, item);
+------+-------+
| pos  | item  |
+------+-------+
| 0    | a     |
| 1    | b     |
| 2    | c     |
+------+-------+
```

### 3、inline

接收一个 Array(\<STRUCT\<f1:t1...fn:tn\>\>) 作为参数， 将STRUCT中的数据返回

![](https://i-blog.csdnimg.cn/blog_migrate/410ec74538ec09e1d3be98028e872555.png)

```mysql
select inline(array(named_struct("id", 1, "name", "zs"), named_struct("id", 2, "name", "ls"),
                    named_struct("id", 3, "name", "ww"))) as (id, name);
+-----+-------+
| id  | name  |
+-----+-------+
| 1   | zs    |
| 2   | ls    |
| 3   | ww    |
+-----+-------+
```

### 4、Lateral View

Latera View 通常与UDTF配合使用。Lateral View可以将UDTF应用到源表的每行数据，将每行数据转换为一行或多行，并将源表中每行的输出结果与该行连接起来，形成一个虚拟表。

![](https://i-blog.csdnimg.cn/blog_migrate/94549b88948e0d018ca0716ca7bab43a.png)

### 5、案例

- 表结构

| movie         | category                     |
| ------------- | ---------------------------- |
| 《疑犯追踪》  | 悬疑，动作，科幻，剧情       |
| 《Lie to me》 | 悬疑，警匪，动作，心理，剧情 |
| 《战狼2》     | 战争，动作，灾难             |

- 建表语句

  ```mysql
  create table movie_info(
      movie string,     --电影名称
      category string   --电影分类
  ) 
  row format delimited fields terminated by "\t";
  ```

- 装载语句

  ```mysql
  insert overwrite table movie_info
  values ("《疑犯追踪》", "悬疑,动作,科幻,剧情"),
         ("《Lie to me》", "悬疑,警匪,动作,心理,剧情"),
         ("《战狼2》", "战争,动作,灾难");
  ```

- 需求说明

根据上述电影信息表，统计各分类的电影数量，期望结果如下：

| 剧情 | 2    |
| ---- | ---- |
| 动作 | 3    |
| 心理 | 1    |
| 悬疑 | 2    |
| 战争 | 1    |
| 灾难 | 1    |
| 科幻 | 1    |
| 警匪 | 1    |

- 答案

  ```mysql
  select
      cate
     ,count(*) as c1
  from
  (
      select 
          movie
         ,split(category, ',') as  category
      from movie_info
  )t1 lateral view explode(category) tmp as cate
  group by cate;
  
  +-------+-----+
  | cate  | c1  |
  +-------+-----+
  | 剧情    | 2   |
  | 动作    | 3   |
  | 心理    | 1   |
  | 悬疑    | 2   |
  | 战争    | 1   |
  | 灾难    | 1   |
  | 科幻    | 1   |
  | 警匪    | 1   |
  +-------+-----+
  ```

## 五、窗口函数





